import { Expense, Participant, Settlement, SettlementSummary } from '../types';

export const calculateSettlements = (
  participants: Participant[],
  expenses: Expense[]
): SettlementSummary => {
  const balances: Record<string, number> = {};
  let totalSpent = 0;

  // Initialize balances
  participants.forEach(p => {
    balances[p.id] = 0;
  });

  // Calculate net balances
  expenses.forEach(expense => {
    const amount = expense.amount;
    const payerId = expense.payerId;
    const involvedIds = expense.involvedIds;

    if (involvedIds.length === 0) return;

    totalSpent += amount;

    // The payer paid the full amount, so they are "owed" this amount initially
    // However, they also consume a portion, which subtracts from what they are owed.
    // Easier mental model: Payer gets +Amount. Everyone involved gets -(Amount/Count).
    
    // 1. Credit the payer
    if (balances[payerId] !== undefined) {
        balances[payerId] += amount;
    }

    // 2. Debit the consumers
    const splitAmount = amount / involvedIds.length;
    involvedIds.forEach(id => {
      if (balances[id] !== undefined) {
        balances[id] -= splitAmount;
      }
    });
  });

  // Generate settlement transactions
  // Greedy algorithm: Match biggest debtor with biggest creditor
  const settlements: Settlement[] = [];
  
  // Separate into debtors (negative balance) and creditors (positive balance)
  let debtors = participants
    .filter(p => balances[p.id] < -0.01) // Use small epsilon for float precision
    .map(p => ({ id: p.id, amount: balances[p.id] }))
    .sort((a, b) => a.amount - b.amount); // Ascending (most negative first)

  let creditors = participants
    .filter(p => balances[p.id] > 0.01)
    .map(p => ({ id: p.id, amount: balances[p.id] }))
    .sort((a, b) => b.amount - a.amount); // Descending (most positive first)

  let i = 0; // debtor index
  let j = 0; // creditor index

  while (i < debtors.length && j < creditors.length) {
    const debtor = debtors[i];
    const creditor = creditors[j];

    // The amount to settle is the minimum of what's owed vs what's receivable
    const amountToSettle = Math.min(Math.abs(debtor.amount), creditor.amount);

    // Record settlement
    settlements.push({
      fromId: debtor.id,
      toId: creditor.id,
      amount: parseFloat(amountToSettle.toFixed(2)),
    });

    // Update remaining amounts
    debtor.amount += amountToSettle;
    creditor.amount -= amountToSettle;

    // Move indices if settled
    if (Math.abs(debtor.amount) < 0.01) i++;
    if (creditor.amount < 0.01) j++;
  }

  return {
    totalSpent,
    balances,
    settlements,
  };
};

export const generateWhatsAppSummary = (
  participants: Participant[],
  settlements: Settlement[],
  expenses: Expense[]
): string => {
  const getParticipantName = (id: string) => participants.find(p => p.id === id)?.name || 'Unknown';

  let text = `*ðŸ“‹ FairShare Expense Summary*\n\n`;

  if (settlements.length === 0) {
    text += `No debts found! All settled up. âœ…\n`;
  } else {
    text += `*Who owes whom:*\n`;
    settlements.forEach(s => {
      text += `â€¢ ${getParticipantName(s.fromId)} â†’ ${getParticipantName(s.toId)}: â‚¹${s.amount}\n`;
    });
  }

  text += `\n*Recent Expenses:*\n`;
  expenses.slice(0, 5).forEach((e, idx) => {
    text += `${idx + 1}. ${e.description} (â‚¹${e.amount}) - Paid by ${getParticipantName(e.payerId)}\n`;
  });

  if (expenses.length > 5) {
    text += `...and ${expenses.length - 5} more.\n`;
  }

  text += `\ngenerated by FairShare App`;
  return encodeURIComponent(text);
};